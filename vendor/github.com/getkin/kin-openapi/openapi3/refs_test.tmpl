// Code generated by go generate; DO NOT EDIT.
package {{ .Package }}

import (
	"context"
	"encoding/json"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)
{{ range $type := .Types }}
func Test{{ $type.Name }}Ref_Extensions(t *testing.T) {
	data := []byte(`{"$ref":"#/components/schemas/Pet","something":"integer","x-order":1}`)

	ref := {{ $type.Name }}Ref{}
	err := json.Unmarshal(data, &ref)
	assert.NoError(t, err)

	// captures extension
	assert.Equal(t, "#/components/schemas/Pet", ref.Ref)
	assert.Equal(t, float64(1), ref.Extensions["x-order"])

	// does not capture non-extensions
	assert.Nil(t, ref.Extensions["something"])

	// validation
	err = ref.Validate(context.Background())
	require.EqualError(t, err, "extra sibling fields: [something]")

	err = ref.Validate(context.Background(), ProhibitExtensionsWithRef())
	require.EqualError(t, err, "extra sibling fields: [something x-order]")

	err = ref.Validate(context.Background(), AllowExtraSiblingFields("something"))
	assert.ErrorContains(t, err, "found unresolved ref") // expected since value not defined

	// non-extension not json lookable
	_, err = ref.JSONLookup("something")
	assert.Error(t, err)
{{ if ne $type.Name "Header" }}
	t.Run("extentions in value", func(t *testing.T) {
		ref.Value = &{{ $type.Name }}{Extensions: map[string]any{}}
		ref.Value.Extensions["x-order"] = 2.0

		// prefers the value next to the \$ref over the one in the \$ref.
		v, err := ref.JSONLookup("x-order")
		assert.NoError(t, err)
		assert.Equal(t, float64(1), v)
	})
{{ else }}
	// Header does not have its own extensions.
{{ end -}}
}
{{ end -}}
